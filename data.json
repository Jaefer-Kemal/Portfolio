{
  "blogPosts": [
    {
      "id": "solving-leetcode-daily",
      "title": "Solving LeetCode Daily with A2SV",
      "date": "May 10, 2024",
      "excerpt": "My approach to solving algorithmic challenges and how being part of A2SV has improved my problem-solving skills.",
      "content": "<p>As a member of Africa to Silicon Valley (A2SV), I've committed to solving at least one LeetCode problem every day. This consistent practice has dramatically improved my algorithmic thinking and problem-solving abilities.</p><h2>The A2SV Approach</h2><p>A2SV has a structured approach to tackling data structures and algorithms:</p><ol><li>Start with the problem statement: Understand exactly what is being asked</li><li>Work through examples: Test your understanding with the provided examples</li><li>Brainstorm approaches: Consider multiple solutions before coding</li><li>Analyze time and space complexity: Optimize before implementation</li><li>Code the solution: Implement the most efficient approach</li><li>Test edge cases: Ensure your solution handles all scenarios</li></ol><h2>My Daily Routine</h2><p>Every morning, I spend 1-2 hours on LeetCode, following these steps:</p><ul><li>Solve the daily challenge</li><li>Review solutions from others</li><li>Document my approach and learnings</li><li>Revisit similar problems to reinforce patterns</li></ul><p>This consistent practice has helped me recognize common patterns in algorithmic problems and develop a toolkit of approaches for different problem types.</p><h2>Key Learnings</h2><p>After months of daily practice, here are some key insights I've gained:</p><p>1. <strong>Pattern recognition is crucial</strong>: Most problems fall into recognizable categories (two pointers, sliding window, DFS/BFS, dynamic programming, etc.)</p><p>2. <strong>Start with brute force</strong>: Always begin with a working solution, then optimize</p><p>3. <strong>Test with examples</strong>: Use the provided examples to validate your understanding</p><p>4. <strong>Edge cases matter</strong>: Always consider empty inputs, single elements, and other boundary conditions</p><p>If you're looking to improve your algorithmic skills, I highly recommend the consistent, structured approach that A2SV promotes. It's transformed my problem-solving abilities and prepared me for technical interviews.</p>"
    },
    {
      "id": "building-clean-rest-apis",
      "title": "Building Clean REST APIs with Django",
      "date": "April 15, 2024",
      "excerpt": "Best practices for designing and implementing RESTful APIs using Django REST Framework.",
      "content": "<p>Django REST Framework (DRF) is a powerful toolkit for building Web APIs in Django. In this post, I'll share best practices I've learned for creating clean, maintainable, and efficient REST APIs.</p><h2>API Design Principles</h2><p>Before writing any code, it's important to establish solid design principles:</p><ul><li><strong>Use resources as your primary abstraction</strong>: Design your API around resources (nouns) rather than actions (verbs)</li><li><strong>Use HTTP methods appropriately</strong>: GET for retrieval, POST for creation, PUT/PATCH for updates, DELETE for removal</li><li><strong>Use nested resources judiciously</strong>: Avoid deeply nested URLs</li><li><strong>Versioning from day one</strong>: Include API versioning in your URL structure</li></ul><h2>Project Structure</h2><p>A well-organized project structure makes your API more maintainable:</p><pre><code>myproject/\n  ├── api/\n  │   ├── __init__.py\n  │   ├── apps.py\n  │   ├── urls.py\n  │   └── v1/\n  │       ├── __init__.py\n  │       ├── serializers/\n  │       ├── views/\n  │       ├── tests/\n  │       └── urls.py\n  ├── myapp/\n  │   ├── models.py\n  │   └── ...\n  └── ...</code></pre><h2>Serializers: The Heart of DRF</h2><p>Serializers convert complex data types (like Django models) to Python primitives that can be rendered into JSON. Here are some best practices:</p><p>1. <strong>Use nested serializers for related objects</strong>:</p><pre><code>class AuthorSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Author\n        fields = ['id', 'name']\n\nclass BookSerializer(serializers.ModelSerializer):\n    author = AuthorSerializer(read_only=True)\n    \n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_date']</code></pre><p>2. <strong>Create separate serializers for different use cases</strong>:</p><pre><code>class BookListSerializer(serializers.ModelSerializer):\n    # Minimal fields for list view\n    class Meta:\n        model = Book\n        fields = ['id', 'title']\n\nclass BookDetailSerializer(serializers.ModelSerializer):\n    # All fields for detail view\n    author = AuthorSerializer(read_only=True)\n    \n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_date', 'description', 'genre']</code></pre><h2>Views and ViewSets</h2><p>ViewSets provide a clean way to organize related views:</p><pre><code>class BookViewSet(viewsets.ModelViewSet):\n    queryset = Book.objects.all()\n    \n    def get_serializer_class(self):\n        if self.action == 'list':\n            return BookListSerializer\n        return BookDetailSerializer\n    \n    def get_queryset(self):\n        queryset = super().get_queryset()\n        genre = self.request.query_params.get('genre')\n        if genre:\n            queryset = queryset.filter(genre=genre)\n        return queryset</code></pre><h2>Authentication and Permissions</h2><p>Security is crucial for any API. DRF provides several authentication methods:</p><pre><code>REST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework.authentication.TokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ],\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.IsAuthenticated',\n    ]\n}</code></pre><p>Custom permissions can be created for fine-grained control:</p><pre><code>class IsAuthorOrReadOnly(permissions.BasePermission):\n    def has_object_permission(self, request, view, obj):\n        # Read permissions are allowed for any request\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        # Write permissions only for the author\n        return obj.author == request.user</code></pre><h2>Testing Your API</h2><p>Comprehensive tests are essential for a reliable API:</p><pre><code>class BookAPITests(APITestCase):\n    def setUp(self):\n        self.user = User.objects.create_user(username='testuser', password='testpass')\n        self.client.force_authenticate(user=self.user)\n        self.author = Author.objects.create(name='Test Author')\n        self.book = Book.objects.create(title='Test Book', author=self.author)\n    \n    def test_get_book_list(self):\n        response = self.client.get('/api/v1/books/')\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)</code></pre><p>By following these best practices, you'll create APIs that are not only functional but also maintainable, secure, and efficient. Django REST Framework provides all the tools you need to build world-class APIs with minimal effort.</p>"
    },
    {
      "id": "deploying-python-projects",
      "title": "Deploying Python Projects to AWS EC2",
      "date": "March 22, 2024",
      "excerpt": "A step-by-step guide to deploying Django applications on AWS EC2 instances with Nginx and Gunicorn.",
      "content": "<p>Deploying a Django application to production involves several steps to ensure it's secure, performant, and reliable. In this guide, I'll walk through the process of deploying a Django application on an AWS EC2 instance using Nginx as a reverse proxy and Gunicorn as the WSGI server.</p><h2>1. Setting Up Your EC2 Instance</h2><p>First, you'll need to create and configure an EC2 instance:</p><ol><li>Log in to the AWS Management Console</li><li>Launch a new EC2 instance (Ubuntu Server is a good choice)</li><li>Configure security groups to allow HTTP (80), HTTPS (443), and SSH (22)</li><li>Create and download your key pair</li><li>Connect to your instance via SSH</li></ol><pre><code>ssh -i your-key.pem ubuntu@your-instance-public-dns</code></pre><h2>2. Installing Required Packages</h2><p>Update your system and install the necessary packages:</p><pre><code>sudo apt update\nsudo apt upgrade -y\nsudo apt install -y python3-pip python3-dev libpq-dev postgresql postgresql-contrib nginx curl</code></pre><p>Create a Python virtual environment:</p><pre><code>sudo apt install -y python3-venv\nmkdir ~/myproject\ncd ~/myproject\npython3 -m venv venv\nsource venv/bin/activate</code></pre><h2>3. Setting Up Your Django Project</h2><p>Clone your project from version control:</p><pre><code>git clone https://github.com/yourusername/yourproject.git\ncd yourproject\npip install -r requirements.txt</code></pre><p>If you don't have a requirements.txt file, create one with your project dependencies:</p><pre><code>pip install django gunicorn psycopg2-binary\npip freeze > requirements.txt</code></pre><p>Configure your Django settings for production:</p><pre><code># settings.py\nDEBUG = False\nALLOWED_HOSTS = ['your-domain.com', 'your-instance-public-ip']\n\n# Use environment variables for sensitive information\nimport os\nSECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')\n\n# Database configuration for PostgreSQL\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'myproject',\n        'USER': 'myprojectuser',\n        'PASSWORD': 'password',\n        'HOST': 'localhost',\n        'PORT': '',\n    }\n}</code></pre><h2>4. Setting Up PostgreSQL</h2><p>Create a database and user:</p><pre><code>sudo -u postgres psql\n\nCREATE DATABASE myproject;\nCREATE USER myprojectuser WITH PASSWORD 'password';\nALTER ROLE myprojectuser SET client_encoding TO 'utf8';\nALTER ROLE myprojectuser SET default_transaction_isolation TO 'read committed';\nALTER ROLE myprojectuser SET timezone TO 'UTC';\nGRANT ALL PRIVILEGES ON DATABASE myproject TO myprojectuser;\n\\q</code></pre><p>Migrate your database:</p><pre><code>python manage.py migrate</code></pre><h2>5. Configuring Gunicorn</h2><p>Test Gunicorn to make sure it can serve your application:</p><pre><code>gunicorn --bind 0.0.0.0:8000 yourproject.wsgi</code></pre><p>Create a systemd service file for Gunicorn:</p><pre><code>sudo nano /etc/systemd/system/gunicorn.service</code></pre><p>Add the following content:</p><pre><code>[Unit]\nDescription=gunicorn daemon\nAfter=network.target\n\n[Service]\nUser=ubuntu\nGroup=www-data\nWorkingDirectory=/home/ubuntu/myproject/yourproject\nExecStart=/home/ubuntu/myproject/venv/bin/gunicorn --access-logfile - --workers 3 --bind unix:/home/ubuntu/myproject/yourproject.sock yourproject.wsgi:application\n\n[Install]\nWantedBy=multi-user.target</code></pre><p>Start and enable the Gunicorn service:</p><pre><code>sudo systemctl start gunicorn\nsudo systemctl enable gunicorn\nsudo systemctl status gunicorn</code></pre><h2>6. Configuring Nginx</h2><p>Create an Nginx server block configuration:</p><pre><code>sudo nano /etc/nginx/sites-available/yourproject</code></pre><p>Add the following content:</p><pre><code>server {\n    listen 80;\n    server_name your-domain.com your-instance-public-ip;\n\n    location = /favicon.ico { access_log off; log_not_found off; }\n    location /static/ {\n        root /home/ubuntu/myproject/yourproject;\n    }\n\n    location /media/ {\n        root /home/ubuntu/myproject/yourproject;\n    }\n\n    location / {\n        include proxy_params;\n        proxy_pass http://unix:/home/ubuntu/myproject/yourproject.sock;\n    }\n}</code></pre><p>Enable the configuration and restart Nginx:</p><pre><code>sudo ln -s /etc/nginx/sites-available/yourproject /etc/nginx/sites-enabled\nsudo nginx -t\nsudo systemctl restart nginx</code></pre><h2>7. Setting Up HTTPS with Let's Encrypt</h2><p>Install Certbot:</p><pre><code>sudo apt install -y certbot python3-certbot-nginx</code></pre><p>Obtain and configure SSL certificates:</p><pre><code>sudo certbot --nginx -d your-domain.com</code></pre><p>Certbot will automatically update your Nginx configuration to use HTTPS.</p><h2>8. Final Steps</h2><p>Collect static files:</p><pre><code>python manage.py collectstatic</code></pre><p>Set up automatic renewal for SSL certificates:</p><pre><code>sudo systemctl status certbot.timer</code></pre><p>Configure your firewall:</p><pre><code>sudo ufw allow 'Nginx Full'\nsudo ufw allow ssh\nsudo ufw enable</code></pre><h2>Conclusion</h2><p>You now have a Django application running on an AWS EC2 instance with Nginx as a reverse proxy, Gunicorn as the application server, and PostgreSQL as the database. This setup provides a robust, scalable environment for your web application.</p><p>For production applications, consider additional steps like:</p><ul><li>Setting up monitoring with tools like Prometheus or CloudWatch</li><li>Implementing a CI/CD pipeline for automated deployments</li><li>Configuring backups for your database</li><li>Setting up a load balancer if you need to scale horizontally</li></ul><p>With these steps, your Django application is ready for production use!</p>"
    }
  ]
}
